package internal

import (
	"fmt"
	"log"

	"github.com/dotdak/protoc-gen-gorm-dao/gorm"
	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type GenOption struct {
	PackageName string
}

func (opt GenOption) GenerateFile(plugin *protogen.Plugin, file *protogen.File) *protogen.GeneratedFile {
	filename := file.GeneratedFilenamePrefix + ".dao.go"
	g := plugin.NewGeneratedFile(filename, file.GoImportPath)
	genGeneratedHeader(g, file)

	g.P("package ", opt.PackageName)
	g.P()
	log.Println(file.GeneratedFilenamePrefix)

	genImportBase(g)
	g.P()

	for _, m := range file.Messages {
		genMessage(g, file, m)
	}

	return g
}

func genGeneratedHeader(g *protogen.GeneratedFile, f *protogen.File) {
	g.P("// Code generated by protoc-gen-gorm-dao. DO NOT EDIT.")

	if f.Proto.GetOptions().GetDeprecated() {
		g.P("// ", f.Desc.Path(), " is a deprecated file.")
	} else {
		g.P("// source: ", f.Desc.Path())
	}
	g.P()
}

func genImportBase(g *protogen.GeneratedFile) {
	g.P("import (")
	g.P("\"gorm.io/gorm\"")
	g.P("\"time\"")
	g.P(")")
}

func genMessage(g *protogen.GeneratedFile, f *protogen.File, m *protogen.Message) {
	if m.Desc.IsMapEntry() {
		return
	}

	if opt, ok := proto.GetExtension(m.Desc.Options(), gorm.E_Opts).(*gorm.GormOptions); !ok || opt == nil || !opt.Orm {
		return
	}
	structName := g.QualifiedGoIdent(m.GoIdent) + "Dao"
	// Message type declaration.
	g.P("type ", structName, " struct {")
	genMessageFields(g, f, m)
	g.P()
	g.P("CreatedAt time.Time")
	g.P("UpdatedAt time.Time")
	g.P("DeletedAt gorm.DeletedAt ")
	g.P("}")
	g.P()

	// g.P("func (d *", structName, ") TableName() string {")
	// g.P("return \"", structName, "s\"")
	// g.P("}")

	g.P("func (d *", structName, ") ToProto() *", m.GoIdent, " {")
	g.P("pb := &", m.GoIdent, "{")

	listMsgAssignment := make([]string, 0, 1)
	for _, field := range m.Fields {
		switch field.Desc.Kind() {
		case protoreflect.MessageKind:
			if field.Desc.IsList() {
				listMsgAssignment = append(listMsgAssignment, field.GoName)
				g.P(field.GoName, ": make([]*", field.Desc.Message().Name(), ", 0, len(d.", field.GoName, ")),")
			} else {
				g.P(field.GoName, ": d.", field.GoName, ".ToProto(),")
			}
		default:
			g.P(field.GoName, ": ", "d.", field.GoName, ",")
		}
	}
	g.P("}")
	g.P()

	for _, arg := range listMsgAssignment {
		g.P("for _, v := range d.", arg, " {")
		g.P("pb.", arg, " = append(pb.", arg, ", v.ToProto())")
		g.P("}")
	}
	g.P()

	g.P("return pb")
	g.P("}")

	g.P("func (d *", structName, ") FromProto(v *", m.GoIdent, ") *", structName, " {")
	g.P("*d = ", structName, "{")

	listMsgFrom := make([][]string, 0, 1)
	for _, field := range m.Fields {
		switch field.Desc.Kind() {
		case protoreflect.MessageKind:
			if field.Desc.IsList() {
				listMsgFrom = append(listMsgFrom, []string{field.GoName, string(field.Desc.Message().Name())})
				g.P(field.GoName, ": make([]*", field.Desc.Message().Name(), "Dao, 0, len(d.", field.GoName, ")),")
			} else {
				g.P(field.GoName, ": (&", field.Desc.Message().Name(), "Dao{}).FromProto(v.", field.GoName, "),")
			}
		default:
			g.P(field.GoName, ": ", "v.", field.GoName, ",")
		}
	}
	g.P("}")
	g.P()

	g.P()
	for _, arg := range listMsgFrom {
		g.P("for _, item := range v.", arg[0], " {")
		g.P("d.", arg[0], " = append(d.", arg[0], ", (&", arg[1], "Dao{}).FromProto(item))")
		g.P("}")
	}
	g.P()
	g.P("return d")
	g.P("}")
}

func genMessageFields(g *protogen.GeneratedFile, f *protogen.File, m *protogen.Message) {
	hasId := false
	for _, field := range m.Fields {
		if field.GoName == "Id" {
			hasId = true
		}
	}

	if !hasId {
		panic(fmt.Sprintf("%s: no Id field in orm message", m.Desc.FullName()))
	}

	for _, field := range m.Fields {
		genMessageField(g, f, m, field)
	}
}

func genMessageField(g *protogen.GeneratedFile, f *protogen.File, m *protogen.Message, field *protogen.Field) {
	if oneof := field.Oneof; oneof != nil && !oneof.Desc.IsSynthetic() {
		// TODO: support oneof
		return
	}
	if field.Desc.IsMap() {
		// TODO: support map
		return
	}

	goType, pointer := fieldGoType(g, field)
	if goType == "" {
		return
	}
	if pointer {
		goType = "*" + goType
	}

	name := field.GoName
	if field.Desc.IsWeak() {
		name = "XXX_weak_" + name
	}

	tags := structTags{
		{"json", fieldJSONTagValue(field)},
	}

	g.AnnotateSymbol(m.GoIdent.GoName+"."+name, protogen.Annotation{Location: field.Location})
	t, ok := proto.GetExtension(field.Desc.Options(), gorm.E_Type).(*gorm.GormType)
	if ok && t != nil {
		tags = append(tags, fieldGormTagValue(t)...)
	}

	g.P(name, " ", goType, tags)
}

func fieldGormTagValue(t *gorm.GormType) structTags {
	switch t.Type.(type) {
	case *gorm.GormType_Index:
		return structTags{{"gorm", "index"}}
	case *gorm.GormType_AutoIncrement:
		return structTags{{"gorm", "autoIncrement"}}
	case *gorm.GormType_NotNull:
		return structTags{{"gorm", "not null"}}
	case *gorm.GormType_Primary:
		return structTags{{"gorm", "primaryKey"}}
	case *gorm.GormType_UniqueIndex:
		return structTags{{"gorm", "uniqueIndex"}}
	default:
		return structTags{}
	}
}

func fieldJSONTagValue(field *protogen.Field) string {
	return string(field.Desc.Name()) + ",omitempty"
}

// // fieldGoType returns the Go type used for a field.
// //
// // If it returns pointer=true, the struct field is a pointer to the type.
func fieldGoType(g *protogen.GeneratedFile, field *protogen.Field) (goType string, pointer bool) {
	if field.Desc.IsWeak() {
		return "struct{}", false
	}

	pointer = field.Desc.HasPresence()
	switch field.Desc.Kind() {
	case protoreflect.BoolKind:
		goType = "bool"
	case protoreflect.EnumKind:
		goType = g.QualifiedGoIdent(field.Enum.GoIdent)
	case protoreflect.Int32Kind, protoreflect.Sint32Kind, protoreflect.Sfixed32Kind:
		goType = "int32"
	case protoreflect.Uint32Kind, protoreflect.Fixed32Kind:
		goType = "uint32"
	case protoreflect.Int64Kind, protoreflect.Sint64Kind, protoreflect.Sfixed64Kind:
		goType = "int64"
	case protoreflect.Uint64Kind, protoreflect.Fixed64Kind:
		goType = "uint64"
	case protoreflect.FloatKind:
		goType = "float32"
	case protoreflect.DoubleKind:
		goType = "float64"
	case protoreflect.StringKind:
		goType = "string"
	case protoreflect.BytesKind:
		goType = "[]byte"
		pointer = false // rely on nullability of slices for presence
	case protoreflect.GroupKind:
		goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent)
		pointer = false // pointer captured as part of the type
	case protoreflect.MessageKind:
		goType = "*" + g.QualifiedGoIdent(field.Message.GoIdent) + "Dao"
		pointer = false // pointer captured as part of the type
	}
	switch {
	case field.Desc.IsList():
		return "[]" + goType, false
	case field.Desc.IsMap():
		keyType, _ := fieldGoType(g, field.Message.Fields[0])
		valType, _ := fieldGoType(g, field.Message.Fields[1])
		return fmt.Sprintf("map[%v]%v", keyType, valType), false
	}
	return goType, pointer
}
